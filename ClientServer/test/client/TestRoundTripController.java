package client;

import java.io.IOException;
import java.util.ArrayList;

import server.ClientState;
import server.IProtocolHandler;
import server.Server;
import xml.Message;
import junit.framework.TestCase;

/**
 * There is a special kind of client-side controller that desires to send a Request to the
 * server and wait for a specific response. If the request is tagged with a unique ID, then
 * use the {@link ServerAccess#sendRequest(IController, Message)} method to have the controller
 * be given the response generated by the server.
 * <p>
 * Note that the use of this behavior is truly optional and is provided as an assistance. 
 * @author heineman
 *
 */
public class TestRoundTripController extends TestCase {

	/** Access to the server for a client. */
	ServerAccess sa;

	/** Server object (the real thing). */
	Server  server;

	/** Is server up and running yet. */
	boolean activeStatus = false;

	/** Client response handler. */
	ClientResponseHandler clientResponseHandler;
	
	/** Helper method for setUp routine. */
	private boolean isActive() {
		return activeStatus;
	}

	/** Utility function to wait a second. */
	private void waitASecond() {
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			
		}
	}
	
	

	// Inner class useful for describing how client processes responses that are specifically
	// being returned to the designated controller.
	class ClientResponseHandler implements IController, IMessageHandler {

		// responses are stored here.
		ArrayList<Message> responses = new ArrayList<Message>();

		@Override
		public void process(Message request, Message response) {
			responses.add(response);			
		}

		@Override
		public void process(Message response) {
			responses.add(response);
		}
	}

	@Override
	protected void setUp() {
		// FIRST thing to do is register the protocol being used. There will be a single class protocol
		// that will be defined and which everyone will use. For now, demonstrate with skeleton protocol.
		if (!Message.configure("skeleton.xsd")) {
			fail ("unable to configure skeleton");
		}

		// server gets started in its own thread.
		// Start server and have ProtocolHandler be responsible for all XML messages.
		server = new Server(new IProtocolHandler() {
			
			@Override
			public Message process(ClientState state, Message request) {
				System.err.println("Should Never Get Here...");
				return null;
			}
		}, 9371);

		try {
			server.bind();
		} catch (IOException ioe) {
			fail ("unable to launch server");
		}

		// Get server processing in its own thread (must be separate)
		new Thread() {
			@Override
			public void run() {
				try {
					activeStatus = true;
					server.process();
				} catch (IOException e) {
					// socket connection happens on server when stopping 
					// suddenly so we do nothing here...
				}
			}
		}.start();


		// this is to be a client connection. Wait until active
		while (!isActive()) {
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				fail ("Can't start up server for some reason.");
			}
		}

		// ready to go!
		sa = new ServerAccess("localhost");
		clientResponseHandler = new ClientResponseHandler();
		sa.connect(clientResponseHandler);
	}

	protected void tearDown() {

		// disconnect client FIRST
		sa.disconnect();

		try {
			server.shutdown();
		} catch (IOException e) {
			System.out.println("Error shutting down server.");
		}
	}

	// send for a matching controller.
	public void testEverything() {
		// send connect message to server through client's ServerAccess
		String xmlString = Message.requestHeader() + "<connectRequest/></request>";
		Message req = new Message(xmlString);
		assertTrue(sa.sendRequest(clientResponseHandler, req));

		// because we use the round trip control, we are indeed waiting.
		assertTrue(sa.isWaiting());
		
		// wait for server to get request and process it, returning response to our 
		// clientResponseHandler
		
		waitASecond();
		
		// retrieve from round trip
		Message m = clientResponseHandler.responses.remove(0);
		assertEquals ("connectResponse", m.contents.getFirstChild().getNodeName());
		
		// simply send a normal response from the server. Find the set of connected IDs, but
		// there will be only one. Send a response to that client
		xmlString = Message.responseHeader(req.id()) + "<connectResponse id='qwerty'/></response>";	
		Message response = new Message(xmlString);
		for (String id : Server.ids()) {
			assertTrue(Server.getState(id).sendMessage(response));
		}
		
		waitASecond();
		
		m = clientResponseHandler.responses.remove(0);
		assertEquals ("connectResponse", m.contents.getFirstChild().getNodeName());
	}

}
